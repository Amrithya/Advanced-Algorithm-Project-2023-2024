# -*- coding: utf-8 -*-
"""Branch and Bound .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JcBtuez-oOW26RwTrqUzM273tCadmZXD
"""

import numpy as np
from collections import deque

def positive_sum(matrix):
    # Helper function to calculate the sum of positive elements in the matrix
    s = 0
    for row in matrix:
        for i in row:
            if i > 0:
                s += i
    return s

def max_segment_branch_and_bound(matrix):
    # Convert the input matrix to a NumPy array
    matrix = np.array(matrix)
    m = matrix.shape[0]  # Number of rows
    n = matrix.shape[1]  # Number of columns

    # Initial partial solution and its positive sum
    initial_partial = ((0, m-1, 0, n-1), np.sum(matrix))

    # Initial best positive sum
    initial_best = positive_sum(matrix)

    def valid(i1, i2, j1, j2):
        # Helper function to check if the indices are within bounds
        return i1 <= i2 and j1 <= j2 and i1 >= 0 and i2 < m and j1 >= 0 and j2 < n

    def matrix_sub_sum(i1, i2, j1, j2):
        # Helper function to calculate the sum of elements in a submatrix
        return np.sum(matrix[i1:i2+1, j1:j2+1])

    def positive_sub_sum(i1, i2, j1, j2):
        # Helper function to calculate the sum of positive elements in a submatrix
        s = 0
        for i in range(i1, i2+1):
            for j in range(j1, j2+1):
                if matrix[i, j] > 0:
                    s += matrix[i, j]
        return s

    def generate_children(partial, best):
        # Helper function to generate children of the current partial solution
        i1, i2, j1, j2 = partial[0]
        children = []

        if valid(i1+1, i2, j1, j2):
            children.append((i1+1, i2, j1, j2))
        if valid(i1, i2-1, j1, j2):
            children.append((i1, i2-1, j1, j2))
        if valid(i1, i2, j1+1, j2):
            children.append((i1, i2, j1+1, j2))
        if valid(i1, i2, j1, j2-1):
            children.append((i1, i2, j1, j2-1))
        return children

    # Initialize a deque with the initial partial solution and its best positive sum
    q = deque([(initial_partial, initial_best)])

    # Initialize a dictionary to store computed values for each partial solution
    d = {initial_partial[0]: (initial_partial[1], initial_best)}

    # BFS to explore all possible solutions
    while q:
        current_partial, current_best = q.popleft()

        for child in generate_children(current_partial, current_best):
            if child not in d.keys():
                # Calculate the total and positive sums for the child
                a = matrix_sub_sum(*child)
                b = positive_sub_sum(*child)
                d[child] = (a, b)

            if d[child][1] > initial_partial[1]:
                # Add the child to the queue if its positive sum is greater than the initial best
                q.append(((child, d[child][0]), d[child][1]))

                if d[child][0] > initial_partial[1]:
                    # Update the initial partial solution if the total sum is greater
                    initial_partial = (child, d[child][0])

    # Extract the final results
    return initial_partial[1], (initial_partial[0][0], initial_partial[0][2]), (initial_partial[0][1], initial_partial[0][3])
